---
title: Node.js
tags: [Node.js]
author: JQiue
article: false
---

::: info 前置知识

+ JavaScript
:::

Node.js 内置 V8 引擎，是 JavaScript 的一个运行环境，提供了浏览器中没有的功能，提供了系统级别的 API，使之能够进行文件的读写，进程的管理，以及网络通信，这在浏览器中是做不到的。Node 使用了事件驱动、非阻塞 I/O 的模型，轻量且高效，同时还提供了包管理工具（NPM），NPM 是全球最大的包管理器，比 Apache Maven 的软件包多两倍以上

Node.js 的目的就是为了实现高性能的 Web 服务器，作者看中的是事件驱动和非堵塞 I/O 模型的优势。C、Lua、Ruby 等语言都曾经作为备选的实现，最终选择 JavaScript 是因为开发门槛低，历史包袱较少，并且 JavaScript 在浏览器中有非常广泛的事件驱动方面的应用，正好符合作者需求，其次，浏览器大战已经分出高下，Chrome 的 JavaScript 引擎 V8 得到性能第一的称号，因此 JavaScript 成为了 Node.js 的实现语言

Node.js 打破了 JavaScript 只能运行在浏览器上的局面，统一了前后端编程环境，大大的降低了前后端转换后带来的代价，对于 Web 开发者来说，学习 JavaScript 不仅仅可以在浏览器上和 UI 打交道，也可以在 Node.js 上随性所欲的访问本地资源

与其他 Web 后端语言相比，Node.js 除了异步和事件以外，回调函数是最大的一个特色，这种方式对于很多习惯同步编程的人来说，也许很不习惯，因为代码的编写顺序与执行顺序没有关系，可能造成阅读上的障碍，因此与常规的同步编程相比，变得不是那么一目了然，但转变了异步思想后，对业务的处理实际上都是一致的

在 Node.js 中，自然保留了 JavaScript 单线程的特点，最大的好处是不用担心有多线程那样到处都是状态同步的问题，没有死锁的存在，也没有线程切换时带来的性能开销。但是单线程也有它自己的弱点，这导致无法利用多核 CPU，错误会引起整个应用崩溃，大量占用 CPU 导致无法继续调用异步 I/O。就像浏览器中一样，长时间的执行 JavaScript 会导致 UI 的渲染和响应被中断，但是这个问题最后被解决了，采取 Web Workers 一样的思路，Node 使用子进程来解决单线程的健壮性和无法利用多核 CPU 的问题

Node.js 适合解决下面这些应用场景中的问题：

+ 处理大流量数据
+ 适合实时交互的应用
+ 完美支持对象数据库（MongoDB）
+ 异步处理大量并发
+ 分布式应用
+ 工具类应用

## 安装 Node.js

+ 用于所有主流平台的官方软件包，可访问[Node.js 官网](http://nodejs.cn/download/)
+ 使用[NVM（Node 版本管理器）](https://github.com/coreybutler/nvm-windows/releases) 安装 Node.js

## 运行 JavaScript

+ 交互式：终端输入`node`即可进入交互式编程
+ 脚本式：将代码写到文件中，在命令行中输入`node 文件名`

## 和浏览器中的一些区别

Node.js 和浏览器都是 JavaScript 的运行环境，但是由于宿主不同所以特点也有所不同

+ 内置对象不同
  + 浏览器提供了`window`全局对象
  + Node.js 的全局对象不叫`window`, 叫`global`

+ this 默认指向不同
  + 浏览器中全局`this`指向`window`
  + Node.js 中全局`this`默认指向空对象`{}`
  
+ API 不同
  + 浏览器提供了操作 BOM/DOM 的相关 API
  + Node.js 中没有 HTML 节点也没有浏览器, 所以 Node.js 没有 DOM/BOM 相关操作

## Server 开发和前端开发的区别

服务端的程序要稳定，必须考虑内存和 CPU，要有一些日志记录，一定是安全的，具有集群和服务拆分的特点，可能会遭受各种恶意的攻击和误操作，客户端独占一个浏览器，不需要考虑内存和 CPU 的问题

Node.js 运行在服务器时，作为 Web Server，运行在本地时作为打包，构建工具。服务端开发的思路和套路和前端是完全不一样的

## 模块

Node.js 借鉴了 CommonJS 来实现了一套模块系统，其中 NPM 对模块的规范完美支持使 Node.js 应用在开发中事半功倍，CommonJS 非常简短，主要有模块引用、模块定义和模块标识三个部分

模块引用：

```js
const math = require('math');
```

`require()`方法是这个规范中用来引入一个模块到当前上下文的功能，接收一个模块标识

模块定义：

```js
exports.foo = function() {};
```

`require()`方法提供了引入模块的功能，而导出模块的功能则交给`exports`对象，它是唯一的导出接口，在这里还存在一个`module`对象，表示当前模块自身，而`exports`是`module`的属性，在 Node.js 中一个文件就是一个模块，将其中变量或方法等挂载到`exports`对象上作为属性，即可在其它地方使用`require()`来导入这个模块使用其中的功能

模块标识就是传递给`require()`方法的参数，必须是小驼峰命名的字符串，或者相对路径，亦或者是绝对路径，可以省略掉文件后缀`.js`

Node.js 中引入模块，需要经历 3 个步骤：

1. 路径分析：对于不同的模块，路径查找方式会有不同，
2. 文件定位：分析扩展名，允许不包含文件的扩展名，但会依次按照`.js`、`.json`、`.node`的顺序补充
3. 编译执行：定位到具体文件后，就会根据路径载入并编译，每个编译成功的模块都会将其路径作为索引缓存在`Module._cache`提高二次引入的性能

在 Node.js 中，模块分为三类：

+ Node.js 提供的核心模块
+ 自定义模块
+ 第三方模块

核心模块在 Node.js 进程启动时就已经被加载到了内存，所以文件定位以及编译执行已经被省略，加载速度最快。对于自定义模块通常是动态加载，必须要完整的引入步骤。对于引入的模块会进行缓存，无论是核心模块还是自定义模块，对相同模块的二次加载都是采用缓存优先的策略，但是核心模块的缓存检查会优先自定义模块

::: tip
在分析标识符的过程中，可能会没有查找到对应文件，但是得到了一个目录，此时会将目录作为一个包来处理，Node 对 CommonJS 进行了一些程度上的支持，这导致会在当前目录下寻找`package.json`，然后解析出包描述对象，并从中取出`main`属性指定的文件名进行定位，如果`main`指定的是错的，或者根本没有`pacakge.json`这个文件，那么会将`index`作为默认的文件名，如果都没有成功定位任何文件，则会抛出异常
:::

Node.js 同样支持 ESM，和 CommonJS 有着很多的异同，由于 CommonJS 是 Node.js 默认支持的模块系统，所以从 CommonJS 切换到 ESM 时，要特别注意

+ 大多数情况下可以使用 ES 模块加载 CommonJS 模块
+ 在 ESM 中没有`__filename`和`__dirname`
+ ESM 中没有 JSON 模块加载
+ 更多详见[这里](http://nodejs.cn/api/esm.html)

## 异步 IO

异步 I/O 对于 Node.js 而言非常重要，异步的概念主要是 JavaScript 在浏览器中是单线程执行的，而且与 UI 渲染共用一个线程，这导致 JavaScript 在执行的时候，UI 渲染和响应处于停滞状态，对于用户来说就会感到页面卡顿，因此用户体验是很差的。但是如果采用异步的方式，JavaScript 和 UI 渲染都不会处于等待，这对用户来说没有感受到卡断，这样的体验无疑是非常美好的

对于前端来说，使用异步可以消除掉 UI 堵塞，但是前端获取资源的速度也取决与后端的响应速度，假如有两个资源需要返回，第一个资源需要耗时 M，第二个资源需要耗时 N，如果采用同步的方式，总共耗时为 M + N。但是如果采用异步的方式，第一个资源的获取并不会堵塞第二个资源的获取，因此总耗时为 max(M, N)。随着复杂性的增加，这种同步和异步的优劣会逐渐的凸显出来，会放大异步和同步在性能上的差距。因此异步 I/O 对于 Node.js 的重要性毋庸置疑，当只有后端更快速的响应资源，前端的体验才能更加美好

<!-- to be update -->