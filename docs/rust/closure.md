---
title: 闭包
category: 编程语言
tag: [Rust]
article: false
---

rust 也支持函数式编程，比如闭包，使用`||`声明，并绑定到变量，就像普通函数一样调用

```rust
let my_closure = || println!("This is a closure");
my_closure();
```

在`||`之间可以添加参数

```rust
let add_one = |n: i32| n + 1;
add_one(1);
```

闭包如果只有一行逻辑，就可以省略`{}`，如果复杂也可以使用`{}`定义代码块

```rust
let add = |a: i32, b: i32| {
  let sum = a + b;
  sum
};
```

闭包还可以直接捕获闭包以外的变量，这就是闭包的由来，它可以捕获作用域返回内的变量

```rust
let a = 1;
let b = 2;
let add = || a + b;
```

## 回调

很多库提供的 API 会使用回调，也就是用户提供的函数，供库在以后调用

## 性能

Rust 的闭包与大多数其他语言中的闭包不同。最大的区别是在有垃圾回收的语言中，可以在闭包中使用局部变量而无须考虑生命期或所有权。Rust 闭包的设计保证它非常快，比函数指针还要快，快到完全可以用
在强度和性能要求极高的环境下。在大多数语言中，闭包是分配在堆上，动态分派，然后由垃圾回收程序负责回收的。因此创建、调用和回收它们都会多花那么一点点 CPU 时间

Rust 闭包完全没有这些性能上的缺点。Rust 就没有垃圾回收。与 Rust 中的其他特性一样，闭包不会被分配到堆上，除非你把它们装到 Box、Vec 或其他容器里。而且因为每个闭包都有一个不同的类型，所以 Rust 编译器只要知道了你所调用闭包的类型，就可以将该闭包的代码行内化
