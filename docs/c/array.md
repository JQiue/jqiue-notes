---
title: 数组
category: 编程语言
tags: [C]
author: JQiue
article: false
---

数组的声明格式很简单：`数据类型 标识符[长度（可选）]`

```c
int arr[3];
double arr[];
```

数组通过下标来访问每个元素，从`0`开始

数组的初始化是在编译阶段进行的

+ 完全初始化 - 即数组多长就给多少个初始化值
+ 部分初始化 - 只给了少于数组长度的初始化值，没有被初始化的部分会被赋值为`0`
+ 没有初始化

```c
int arr1[3] = {1, 2, 6};
int arr2[3] = {3};
int arr3[3];
```

数组可以指定初始化某个位置的值，其余未初始化的会被初始化为`0`。如果后面还有更多的值，这些会用于初始化指定元素后面的元素

```c
int arr1[3] = {[2] = 22};
printf("%d", arr1[2]); // 22

int arr2[5] = {[2] = 3, 4, 5};
printf("%d", arr2[2]); // 3
printf("%d", arr2[3]); // 4
printf("%d", arr2[4]); // 5
```

如果没有指定长度，那么数组就会设置成足够装得下初始化的值

```c
int arr[] = {[5] = 6};
printf("%d", arr[5]); // 6
```

## 计算大小

`sizeof`可以返回一个数组占据的内存大小，但是每一个元素类型大小是相同的，利用这一点可以计算出元素的个数

```c
int arr[] = {1, 2, 3};
printf("%d", sizeof(arr)); // 12
printf("%d", sizeof(arr) / sizeof(int)); // 3
```

但是有一种情况例外，数组作为函数参数时`sizeof`无法准确计算数组大小。这是因为函数调用时会形成一个调用栈，数字可以很大，每次拷贝整个数组会耗费大量的内存，所以编译器看到数组作为函数参数时，不会拷贝整个数组，而是拷贝数组第一个元素的首地址

```c
void foo(int arr[])
{
  printf("%d", sizeof(arr)); // ?
}

int main(void)
{
  int arr[] = {1, 2, 3};
  foo(arr);
  printf("%d", sizeof(arr)); // 12
  return 0;
}
```

这里有一个小技巧，就是在计算元素的大小时使用`sizeof(arr[0])`，而不是直接指定数组类型

```c
int arr[] = {1, 2, 3};
printf("%d", sizeof(arr) / sizeof(arr[0]));
```

## 多维数组

数组中的每一个元素也可以是一个数组，因此就有了多维数组的存在，最常用的是用二维数组来表示矩阵

```c
int arr[3][2];
```

::: tip
在二维数组中可以不用写行数，但列数必须写
:::

## 字符数组

在讨论字符数组时，基本上就是在讨论字符串，字符串就是一组字符组成的。C 没有提供专门存储字符串的变量类型，字符串被存储在`char`类型的数组中，每个单元存储一个字符串中的字符，并且在末尾都有一个`\0`表示字符串的结束，这意味着数组的容量至少比字符串的字符数量多一个。这个可以用`string.h`提供的`strlen()`来验证，因为它只会计算字符个数，而不会计算不可见的末尾字符，但是`sizeof`会计算所有的占用字节数，所以通常更大

```c
char str[] = "hello"; 
printf("%d\n", sizeof(str));  // 6
printf("%d\n", strlen(str)); // 5
```

由此可见一般，C 中的字符串就是一个以空字符结尾的字符序列

而且还有一种定义字符串的格式，最后一个元素必须是'\0'，表示字符串的结束标识，并且不能够写中文

```c
char str[] = {'a','b','c',...,'\0'};
```

虽然使用`printf()`输出一个字符串通常使用`%s`，但更常用的是使用`puts`函数和`gets`函数来输出和输入字符串，`puts`只会显示字符串，且在末尾加上换行符

### 字符串函数

+ `int strlen(str)`：计算字符个数
+ `strcat(str1, str2)`：拼接字符串
+ `strcmp(str1, str2)`：比较字符串
+ `strcpy(char*, char*)`：拷贝字符串

## 边界问题

C 不会检查数组的越界访问，索引值超出了数组定义的大小并不会报错。这么做的原因是，C 相信人不会做出越界的傻事，由于它不需要进行边界检查，数组运行的更快
