---
title: 数组和字符串
category: 编程语言
tags: [Alpha]
author: JQiue
article: false
---

## 用法

### 定义

数组声明格式很简单：`数据类型 标识符[长度（可选）]`

```c
int arr[3];
double arr[];
```

### 访问元素

数组通过下标来访问，从`0`开始

### 初始化

数组的初始化是在编译阶段进行的

1. 完全初始化：即数组多长就给多少个初始化值
2. 部分初始化：只给了少于数组长度的初始化值，没有被初始化的部分会被赋值为 0
3. 没有初始化

```c
int arr1[3] = {1, 2, 6};
int arr2[3] = {3};
int arr3[3];
```

### 指定初始化

这个特性可以初始化指定的元素，其余未初始化的会被初始化为`0`

```c
int arr[3] = {[2] = 22};
printf("%d", arr[2]); // 22
```

如果初始化后还有更多的值，这些会用于初始化指定元素后面的元素

```c
int arr[5] = {[2] = 3, 4, 5};
printf("%d", arr[2]); // 3
printf("%d", arr[3]); // 4
printf("%d", arr[4]); // 5
```

假如没有指定数组长度，那么数组就会设置成足够装得下初始化的值

```c
int arr[] = {[5] = 6};
printf("%d", arr[5]); // 6
```

## 二维数组

数组中的每一个元素也可以是一个数组，因此就有了多维数组的存在，最常用的是二维数组

```c
int arr[3][2];
```

::: tip
在二维数组中可以不用写行数，但列数必须写
:::

## 字符串

C 没有提供专门存储字符串的变量类型，字符串被存储在`char`类型的数组中，每个单元存储一个字符串中的字符，并且在末尾都有一个`\0`表示字符串的结束，这意味着数组的容量至少比字符串的字符数量多一个，这个可以用`string.h`提供的`strlen()`来验证，因为它只会计算字符个数，而不会计算不可见的末尾字符，但是`sizeof`会计算所有的占用字节数，所以通常更大

```c
char str[] = "hello"; 
printf("%d\n", sizeof str);  // 6
printf("%d\n", strlen(str)); // 5
```

由此可见一般，C 中的字符串就是一个以空字符结尾的字符序列

而且还有一种定义字符串的格式，最后一个元素必须是'\0'，表示字符串的结束标识，并且不能够写中文

```c
char 数组名[] = {'字符1','字符2','字符3',...,'\0'};
```

虽然使用`printf()`输出一个字符串通常使用`%s`，但更常用的是使用`puts`函数和`gets`函数来输出和输入字符串，`puts`只会显示字符串，且在末尾加上换行符

### 字符串数组

### 字符串函数

+ `int strlen(str)`：计算字符个数
+ `strcat(str1, str2)`：拼接字符串
+ `strcmp(str1, str2)`：比较字符串
+ `strcpy(char*, char*)`：拷贝字符串

## 数组和指针

数组名就是数组首元素的地址，那么下面就是成立的

```c
int arr[] = {1, 2, 3};
arr == &arr[0];        // 等价的
printf("%d", arr[0]);  // 1
printf("%d", *arr);    // 1
```

## 边界问题

C 不会检查数组的越界访问，索引值超出了数组定义的大小并不会报错，这么做的原因是，C 相信人不会做出越界的傻事，它不需要进行边界检查，数组运行的更快
