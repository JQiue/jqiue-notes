---
title: 介绍
author: JQiue
article: false
---

::: info 前置知识

+ 编程语言
:::

数据是数据对象的简称，结构是指数据对象相互之间的关系，也就是各种数据的排列方式，因此数据结构是**相互之间存在一种或多种特定关系的数据元素的集合**，数据结构是一门研究非数字计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作等的学科

## 基本概念和术语

数据结构由两个词语组成，首先得说明数据是什么

+ 数据：数据是一个描述客观事物的符号，也是计算机能够操作的对象，能够被计算机识别并输入给计算机处理的符号集合，数值、文字、图像、音频、视频等都是一种数据，区别在于一个是数值类型和非数值类型，也可以这么说计算机中的数据无处不在
+ 数据元素：是组成数据的基本单位，通常被称之为一条记录，比如人类中的人本身就是一种数据元素
+ 数据项：一个数据元素由多个数据项组成，比如人有性别、年龄、身高等数据项，而数据项是最小的不可分割单位，但真正讨论问题的时候，并不会将数据项作为一个角度研究，往往将数据元素看作一个整体研究的着眼点
+ 数据对象：是相同性质的数据元素的集合

## 形式定义的数据结构

一个数据结构的形式定义，可描述为是一个二元组 Data_structures = (D, S)

其中：D 是数据元素的有限集，S 是 D 之间的相互关系有限集

假设两个元素 x 和 y，则可以用 `<x, y>` 表示由 x 指向 y，用 (x, y) 表示由 x 和 y 有特定关系

举例：D = {a~i~ | a~1~, a~2~, a~3~, a~4~, a~5~} , S = {<a~1~,a~2~>,<a~2~,a~3~>, <a~3~,a~4~>, <a~4~,a~5~>}

举例：D = {a~i~ | a~1~, a~2~, a~3~, a~4~, a~5~} , S = {(a~1~,a~2~),(a~2~,a~3~), (a~3~,a~4~), (a~4~,a~5~)}

## 逻辑结构和物理结构

### 逻辑结构

逻辑结构指的是数据对象中的数据元素之间的相互关系，主要分为四种：

+ 集合结构：数据元素除了同属于一个集合以外，它们之间没有任何关系，就跟数学中的集合一样
+ 线性结构：数据元素之间只有一对一的关系
+ 树形结构：数据元素之间是一对多的关系
+ 图形结构：数据元素之间是多对多的关系

### 物理结构

物理结构也叫存储结构，指的是如何将数据存储在存储器中

+ 顺序存储：把数据元素存放在连续的地址空间里，存储关系能够反映其逻辑关系，数组就是这种结构
+ 链式存储：把数据元素存放在任意的地址空间里，也可以是连续的，但是存储关系不能反映其逻辑关系，每一个数据元素还需要额外的空间来存储下一个数据元素的地址
+ 索引存储：分别存放数据元素和元素之间的关系的存储方式
+ 散列存储：将数据元素的地址空间与关键码之间建立确定的对应关系的存储方式

::: tip
逻辑结构针对于数据的定义，物理结构针对于数据的存储实现，二者基本目标是将数据及其逻辑关系存储到存储器中
:::

## 抽象数据结构类型

### 数据类型

计算机中的内存不是无限大的，为了更好的管理数据对内存空间的占用，就划分了数据类型，避免对内存空间的浪费，本质上是对于一个值的取值范围划分

### 抽象数据类型

抽象是指抽取事物中具有的普遍性的本质，抽出问题的特征而忽略非本质的细节，是一种思考方式，它隐藏了细节，只保留实现目标所必需的信息，与存放数据的机器无关，与数据存储的物理结构无关，与实现操作的算法和编程语言无关，只关心数据和操作是什么，并不涉及如何实现

对已有的数据类型进行抽象，就有了**抽象数据类型（Abstract Data Type，ADT）**

一个 ADT 包含两个部分：数据的声明和运算的声明

```plain
ADT 抽象数据类型名
Data
    数据元素之间逻辑关系的定义
Operation
    操作 1
        初始条件
        操作结果描述
    操作 2
        初始条件
        操作结果描述
    操作 n
        ...
endADT
```

## 线性表的定义

线性表是具有 n 个相同类型元素的有线序列（n >= 0）

如果将线性表记为：

::: center
a~1~,  a~2~,  ...,  a~i-1~,  a~i~,  a~i+1~,  ...,  a~n~
:::

+ 则 a~i-1~ 位于 a~i~ 的前面，a~i~ 位于 a~i+1~ 的前面
+ a~i-1~ 是 a~i~ 的直接前驱，a~i+1~ 是 a~i~ 的直接后驱
+ a~1~ 只有直接后驱，a~n~ 只有直接前驱

地址计算方法：

address(a~i~) = address(a~i-1~) + n = address(a~0~) + n * (i - 1)

::: tip
n：每个元素所占的字节数
:::
