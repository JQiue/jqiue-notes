import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as n}from"./app-BvEWR9Cw.js";const t={};function l(h,i){return n(),a("div",null,i[0]||(i[0]=[e(`<p>Rust 借鉴了 JavaScript 来编写异步编程，当需要高并发，异步 I/O 就需要改模型了</p><p>Rust 和 JavaScript 有所不同：</p><ul><li>Future 是惰性的，只有被轮询时才会执行</li><li>没有内置异步调用所必需的运行时</li><li>运行时同时支持单线程和多线程</li></ul><p>异步和多线程都可以实现并发编程，但异步更适合 IO 密集型任务，可以有效地降低 CPU 和内存的负担</p><h2 id="futures" tabindex="-1"><a class="header-anchor" href="#futures"><span>Futures</span></a></h2><p><code>async/.await</code>是 Rust 提供的特性，通过<code>async</code>标记的函数会转换为 Future，Future 执行遇到堵塞会让出线程的控制权，这就不会导致线程堵塞，首先需要引入<code>futures</code>包</p><div class="language-toml line-numbers-mode" data-highlighter="shiki" data-ext="toml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">dependencies</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">futures</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;0.3&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>创建一个异步函数</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">async</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;foo&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即使调用它也不会执行，因为 Future 是惰性的</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时应使用<code>block_on</code>执行器等待 Future 的完成，让代码看起来像同步的</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> futures</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">executor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::block_on;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  block_on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想在一个异步函数中调用另一个异步函数，可以使用<code>.await</code>语法进行调用</p><div class="language-rust line-numbers-mode" data-highlighter="shiki" data-ext="rust" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">async</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> bar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;bar&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">async</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> fn</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  println!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;foo&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  bar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">await</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Futures 更适合于需要更底层控制的场景，或者想要自行构建异步运行时的场景</p><h2 id="tokio" tabindex="-1"><a class="header-anchor" href="#tokio"><span>Tokio</span></a></h2><p>Tokio 是在 Futures 之上构建的一个功能更加丰富的异步运行时库，更适合于大多数常见的网络编程、I/O密集型应用开发场景，提供了更加开箱即用的功能</p><p>Tokio 的主要特点包括：</p><ul><li>高性能：Tokio 使用 Rust 的并发特性和内存管理，可以提供非常高的性能和吞吐量</li><li>可扩展性：Tokio 支持各种异步 I/O 原语，如 TCP、UDP、文件 I/O 等，可以用于构建各种类型的异步应用程序</li><li>易用性：Tokio 提供了一个易于使用的API，隐藏了底层的异步细节，使开发人员可以专注于应用程序逻辑</li><li>可靠性：Tokio 利用 Rust 的类型系统和所有权模型，可以帮助开发人员编写安全和正确的异步代码</li></ul>`,20)]))}const k=s(t,[["render",l]]),d=JSON.parse(`{"path":"/rust/async.html","title":"异步编程","lang":"zh-CN","frontmatter":{"title":"异步编程","category":"编程语言","tag":["Rust"],"article":false,"order":10,"description":"Rust 借鉴了 JavaScript 来编写异步编程，当需要高并发，异步 I/O 就需要改模型了 Rust 和 JavaScript 有所不同： Future 是惰性的，只有被轮询时才会执行 没有内置异步调用所必需的运行时 运行时同时支持单线程和多线程 异步和多线程都可以实现并发编程，但异步更适合 IO 密集型任务，可以有效地降低 CPU 和内存的负...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"异步编程\\",\\"description\\":\\"Rust 借鉴了 JavaScript 来编写异步编程，当需要高并发，异步 I/O 就需要改模型了 Rust 和 JavaScript 有所不同： Future 是惰性的，只有被轮询时才会执行 没有内置异步调用所必需的运行时 运行时同时支持单线程和多线程 异步和多线程都可以实现并发编程，但异步更适合 IO 密集型任务，可以有效地降低 CPU 和内存的负...\\"}"],["meta",{"property":"og:url","content":"https://jinqiu.wang/rust/async.html"}],["meta",{"property":"og:site_name","content":"JQiue's notes"}],["meta",{"property":"og:title","content":"异步编程"}],["meta",{"property":"og:description","content":"Rust 借鉴了 JavaScript 来编写异步编程，当需要高并发，异步 I/O 就需要改模型了 Rust 和 JavaScript 有所不同： Future 是惰性的，只有被轮询时才会执行 没有内置异步调用所必需的运行时 运行时同时支持单线程和多线程 异步和多线程都可以实现并发编程，但异步更适合 IO 密集型任务，可以有效地降低 CPU 和内存的负..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-19T06:51:15.000Z"}],["meta",{"property":"article:tag","content":"Rust"}],["meta",{"property":"article:modified_time","content":"2025-06-19T06:51:15.000Z"}]]},"git":{"createdTime":1750315875000,"updatedTime":1750315875000,"contributors":[{"name":"JQiue","username":"JQiue","email":"861947542@qq.com","commits":1,"url":"https://github.com/JQiue"}]},"readingTime":{"minutes":1.86,"words":557},"filePathRelative":"rust/async.md","excerpt":"<p>Rust 借鉴了 JavaScript 来编写异步编程，当需要高并发，异步 I/O 就需要改模型了</p>\\n<p>Rust 和 JavaScript 有所不同：</p>\\n<ul>\\n<li>Future 是惰性的，只有被轮询时才会执行</li>\\n<li>没有内置异步调用所必需的运行时</li>\\n<li>运行时同时支持单线程和多线程</li>\\n</ul>\\n<p>异步和多线程都可以实现并发编程，但异步更适合 IO 密集型任务，可以有效地降低 CPU 和内存的负担</p>\\n<h2>Futures</h2>\\n<p><code>async/.await</code>是 Rust 提供的特性，通过<code>async</code>标记的函数会转换为 Future，Future 执行遇到堵塞会让出线程的控制权，这就不会导致线程堵塞，首先需要引入<code>futures</code>包</p>","autoDesc":true}`);export{k as comp,d as data};
