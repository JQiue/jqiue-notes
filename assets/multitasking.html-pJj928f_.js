import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as r,f as n,b as t,o as d}from"./app-BvEWR9Cw.js";const c={};function u(i,e){return d(),o("div",null,[e[0]||(e[0]=r('<p>只需要继承<code>Thread</code>，重写<code>run</code>方法，把新线程要做的事写在<code>run</code>方法中，创建线程对象，开启新线程, 内部会自动执行<code>run</code>方法</p><p>或者定义类实现<code>Runnable</code>接口，创建自定义的<code>Runnable</code>的子类对象，创建<code>Thread</code>对象, 传入<code>Runnable</code>，调用<code>start()</code>开启新线程, 内部会自动调用<code>Runnable</code>的<code>run()</code>方法</p><p><code>Thread</code>代码简单，但如果已经有了父类，就不能用这种方法</p><p><code>Runnable</code>代码复杂，即使自己定义的线程类有了父类也没关系，因为有了父类也可以实现接口，而且接口是可以多实现的。坏处是不能直接使用<code>Thread</code>中的方法需要先获取到线程对象后，才能得到<code>Thread</code>的方法，代码复杂</p><h2 id="同步" tabindex="-1"><a class="header-anchor" href="#同步"><span>同步</span></a></h2>',5)),n(" todo "),e[1]||(e[1]=t("h2",{id:"安全",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#安全"},[t("span",null,"安全")])],-1)),e[2]||(e[2]=t("p",null,"多线程并发操作同一数据时, 就有可能出现线程安全问题，使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作",-1)),e[3]||(e[3]=t("p",null,"Vector 是线程安全的,ArrayList是线程不安全的，StringBuffer是线程安全的,StringBuilder是线程不安全的，Hashtable是线程安全的,HashMap是线程不安全的",-1)),n(" todo ")])}const s=a(c,[["render",u]]),m=JSON.parse(`{"path":"/java/multitasking.html","title":"多任务处理","lang":"zh-CN","frontmatter":{"title":"多任务处理","category":"编程语言","tag":["Java"],"article":false,"order":7,"description":"只需要继承Thread，重写run方法，把新线程要做的事写在run方法中，创建线程对象，开启新线程, 内部会自动执行run方法 或者定义类实现Runnable接口，创建自定义的Runnable的子类对象，创建Thread对象, 传入Runnable，调用start()开启新线程, 内部会自动调用Runnable的run()方法 Thread代码简单，但...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"多任务处理\\",\\"description\\":\\"只需要继承Thread，重写run方法，把新线程要做的事写在run方法中，创建线程对象，开启新线程, 内部会自动执行run方法 或者定义类实现Runnable接口，创建自定义的Runnable的子类对象，创建Thread对象, 传入Runnable，调用start()开启新线程, 内部会自动调用Runnable的run()方法 Thread代码简单，但...\\"}"],["meta",{"property":"og:url","content":"https://jinqiu.wang/java/multitasking.html"}],["meta",{"property":"og:site_name","content":"JQiue's notes"}],["meta",{"property":"og:title","content":"多任务处理"}],["meta",{"property":"og:description","content":"只需要继承Thread，重写run方法，把新线程要做的事写在run方法中，创建线程对象，开启新线程, 内部会自动执行run方法 或者定义类实现Runnable接口，创建自定义的Runnable的子类对象，创建Thread对象, 传入Runnable，调用start()开启新线程, 内部会自动调用Runnable的run()方法 Thread代码简单，但..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-19T06:51:15.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2025-06-19T06:51:15.000Z"}]]},"git":{"createdTime":1750315875000,"updatedTime":1750315875000,"contributors":[{"name":"JQiue","username":"JQiue","email":"861947542@qq.com","commits":1,"url":"https://github.com/JQiue"}]},"readingTime":{"minutes":1.1,"words":330},"filePathRelative":"java/multitasking.md","excerpt":"<p>只需要继承<code>Thread</code>，重写<code>run</code>方法，把新线程要做的事写在<code>run</code>方法中，创建线程对象，开启新线程, 内部会自动执行<code>run</code>方法</p>\\n<p>或者定义类实现<code>Runnable</code>接口，创建自定义的<code>Runnable</code>的子类对象，创建<code>Thread</code>对象, 传入<code>Runnable</code>，调用<code>start()</code>开启新线程, 内部会自动调用<code>Runnable</code>的<code>run()</code>方法</p>","autoDesc":true}`);export{s as comp,m as data};
