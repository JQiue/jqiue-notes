import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,f as r,o}from"./app-BvEWR9Cw.js";const p={};function i(c,t){return o(),a("div",null,[t[0]||(t[0]=n('<h2 id="软件系统的分层" tabindex="-1"><a class="header-anchor" href="#软件系统的分层"><span>软件系统的分层</span></a></h2><h3 id="应用层与实现层" tabindex="-1"><a class="header-anchor" href="#应用层与实现层"><span>应用层与实现层</span></a></h3><p>主观上对系统按照用户需求和内在技术原理进行划分，其实是在区分应用层与实现层。应用层中的所有内容都是从用户需求出发的（比如想要听音乐，想要拍照片，想要订酒店）。实现层中的一切都是使得这些需求落地实现的内容（比如，将电信号转变成模拟信号，在数码相机中识别一个像素的颜色，或者将信息通过互联网传给一个预设的系统）。实现层中的所有内容本质上都是技术性的，并且都会被当作达到目标的方法</p><h3 id="功能性与非功能性" tabindex="-1"><a class="header-anchor" href="#功能性与非功能性"><span>功能性与非功能性</span></a></h3><p>考虑一个系统能够做什么和这个系统做得怎么样是有区别的，这就是对系统做功能性和非功能性划分的基础</p><p>功能性特征的例子包括通过网络发送数据、播放音乐、拍摄照片和修改图片中一个特定的像素。非功能性特征的例子包括一个好看的可视化用户界面，快速运行的软件，以及安全、私密地保存用户数据的能力。对于一个软件系统而言，安全性与完备性这两类非功能性特征非常重要。完备性指的是如何设计系统的运行规则，并让系统具备诸如安全性和正确性等很多特征。我们可以通过英语中对语法的使用来帮助你理解功能性和非功能性特征之间的区别：动词描述了动作或已经完成的行为，而副词描述了一个动作是如何被完成的。举个例子，一个人能够快步走或慢步走。无论快慢，走这个动作是一样的，而这个动作的表现是有区别的。按照这样的理解，你可以认为功能性特征和动词相似，而非功能性特征和副词相似</p><h3 id="同时使用两种划分标准" tabindex="-1"><a class="header-anchor" href="#同时使用两种划分标准"><span>同时使用两种划分标准</span></a></h3><p>对于一个软件系统，我们可以在识别其技术性特征与非技术性特征的同时识别应用层与实现层</p><table><thead><tr><th>分层</th><th>功能性特征</th><th>非功能性特征</th></tr></thead><tbody><tr><td>应用层</td><td>拍照片，打电话，上网，玩游戏</td><td>拥有漂亮的用户界面，操作简单</td></tr><tr><td>实现层</td><td>永久保存本地数据，自动连接最近的基站</td><td>高效存储数据，省电</td></tr></tbody></table><h3 id="完备性" tabindex="-1"><a class="header-anchor" href="#完备性"><span>完备性</span></a></h3><p>完备性在任何软件系统中都是重要的非功能性特征，它往往包含以下 3 个方面的内容</p><ul><li>数据完备性：软件系统中的数据要完整、正确且无冲突</li><li>行为完备性：软件系统要可顺利运行，并且保证不存在逻辑错误</li><li>安全性：软件系统只对认证用户授权有限的数据访问与使用功能</li></ul><p>很重要的一点是，几乎每个人都认为任何一个软件系统都应该具有如上所述的完备性，而忽略了在软件系统背后付出巨大时间和精力的软件工程师，并且只有在软件系统出现各类问题时，才会意识到完备性的重要性。因此，当意识到软件工程师们为了高度完备性所做出的努力时，我们会有种被宠坏的感觉。但是当使用的系统出现问题时，我们的感觉就完全不同了。当你遇到数据丢失，或发现陌生人可以访问你的数据时，你会感觉非常不好。而当手机、计算机、电子邮箱、Word 或 Execl 出问题让你感到生气时，你会忘记自己的好脾气！在这些情景中，我们开始意识到软件完备性是多么重要。因此，我们就不需要诧异为什么如此多的专家会把大量的时间和努力花费在实现层中这些看着不起眼的非功能性特征上了</p>',13)),r(" todo ")])}const h=e(p,[["render",i]]),l=JSON.parse(`{"path":"/sundry/blockchain.html","title":"区块链","lang":"zh-CN","frontmatter":{"title":"区块链","category":"知识分享","article":false,"description":"软件系统的分层 应用层与实现层 主观上对系统按照用户需求和内在技术原理进行划分，其实是在区分应用层与实现层。应用层中的所有内容都是从用户需求出发的（比如想要听音乐，想要拍照片，想要订酒店）。实现层中的一切都是使得这些需求落地实现的内容（比如，将电信号转变成模拟信号，在数码相机中识别一个像素的颜色，或者将信息通过互联网传给一个预设的系统）。实现层中的所有...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"区块链\\",\\"description\\":\\"软件系统的分层 应用层与实现层 主观上对系统按照用户需求和内在技术原理进行划分，其实是在区分应用层与实现层。应用层中的所有内容都是从用户需求出发的（比如想要听音乐，想要拍照片，想要订酒店）。实现层中的一切都是使得这些需求落地实现的内容（比如，将电信号转变成模拟信号，在数码相机中识别一个像素的颜色，或者将信息通过互联网传给一个预设的系统）。实现层中的所有...\\"}"],["meta",{"property":"og:url","content":"https://jinqiu.wang/sundry/blockchain.html"}],["meta",{"property":"og:site_name","content":"JQiue's notes"}],["meta",{"property":"og:title","content":"区块链"}],["meta",{"property":"og:description","content":"软件系统的分层 应用层与实现层 主观上对系统按照用户需求和内在技术原理进行划分，其实是在区分应用层与实现层。应用层中的所有内容都是从用户需求出发的（比如想要听音乐，想要拍照片，想要订酒店）。实现层中的一切都是使得这些需求落地实现的内容（比如，将电信号转变成模拟信号，在数码相机中识别一个像素的颜色，或者将信息通过互联网传给一个预设的系统）。实现层中的所有..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-19T06:51:15.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-19T06:51:15.000Z"}]]},"git":{"createdTime":1750315875000,"updatedTime":1750315875000,"contributors":[{"name":"JQiue","username":"JQiue","email":"861947542@qq.com","commits":1,"url":"https://github.com/JQiue"}]},"readingTime":{"minutes":3.57,"words":1072},"filePathRelative":"sundry/blockchain.md","excerpt":"<h2>软件系统的分层</h2>\\n<h3>应用层与实现层</h3>\\n<p>主观上对系统按照用户需求和内在技术原理进行划分，其实是在区分应用层与实现层。应用层中的所有内容都是从用户需求出发的（比如想要听音乐，想要拍照片，想要订酒店）。实现层中的一切都是使得这些需求落地实现的内容（比如，将电信号转变成模拟信号，在数码相机中识别一个像素的颜色，或者将信息通过互联网传给一个预设的系统）。实现层中的所有内容本质上都是技术性的，并且都会被当作达到目标的方法</p>\\n<h3>功能性与非功能性</h3>\\n<p>考虑一个系统能够做什么和这个系统做得怎么样是有区别的，这就是对系统做功能性和非功能性划分的基础</p>","autoDesc":true}`);export{h as comp,l as data};
